/*
 * Copyright (C) 2025 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.server.devicepolicy;

import static android.Manifest.permission.MANAGE_DEFAULT_APPLICATIONS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_FUNCTIONS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_RESTRICTIONS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ASSIST_CONTENT;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_AUTOFILL;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_BLUETOOTH;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_CALLS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_CAMERA_TOGGLE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_CERTIFICATES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_CONTENT_PROTECTION;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_DEFAULT_SMS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_DISPLAY;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_FUN;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_INPUT_METHODS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_KEYGUARD;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCALE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCATION;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_LOCK_TASK;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_MTE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_PACKAGE_STATE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_PRINTING;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_PROFILE_INTERACTION;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CAPTURE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SECURITY_LOGGING;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SMS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_STATUS_BAR;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_THREAD_NETWORK;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_TIME;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_VPN;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_WALLPAPER;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIFI;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_WINDOWS;
import static android.Manifest.permission.MANAGE_DEVICE_POLICY_WIPE_DATA;
import static android.Manifest.permission.QUERY_ADMIN_POLICY;
import static android.Manifest.permission.SET_TIME;
import static android.Manifest.permission.SET_TIME_ZONE;
import static android.app.admin.DevicePolicyManager.DELEGATION_APP_RESTRICTIONS;
import static android.app.admin.DevicePolicyManager.DELEGATION_BLOCK_UNINSTALL;
import static android.app.admin.DevicePolicyManager.DELEGATION_CERT_INSTALL;
import static android.app.admin.DevicePolicyManager.DELEGATION_PACKAGE_ACCESS;
import static android.app.admin.DevicePolicyManager.DELEGATION_PERMISSION_GRANT;
import static android.app.admin.DevicePolicyManager.DELEGATION_SECURITY_LOGGING;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import static com.android.server.devicepolicy.DevicePolicyManagerService.AFFILIATED_PROFILE_OWNER_ON_USER;
import static com.android.server.devicepolicy.DevicePolicyManagerService.DEFAULT_DEVICE_OWNER;
import static com.android.server.devicepolicy.DevicePolicyManagerService.DpcType;
import static com.android.server.devicepolicy.DevicePolicyManagerService.FINANCED_DEVICE_OWNER;
import static com.android.server.devicepolicy.DevicePolicyManagerService.NOT_A_DPC;
import static com.android.server.devicepolicy.DevicePolicyManagerService.PROFILE_OWNER;
import static com.android.server.devicepolicy.DevicePolicyManagerService.PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE;
import static com.android.server.devicepolicy.DevicePolicyManagerService.PROFILE_OWNER_ON_USER;
import static com.android.server.devicepolicy.DevicePolicyManagerService.PROFILE_OWNER_ON_USER_0;

import android.annotation.NonNull;
import android.annotation.UserIdInt;
import android.app.admin.flags.Flags;
import android.content.Context;
import android.os.UserManager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

/**
 * A helper class that takes into account both permissions granted to the caller app,
 * as well as permissions implicitly granted to the DPC role of the caller.
 *
 * Each instance of this class is tightly tied to a single caller, so a new instance of this class
 * is needed to check the permissions of a new caller.
 */
// DoNotPush maybe `CallerPermissionChecker` or `PermissionEnforcer`? `PermissionHelper`?
class PermissionChecker {
    private final Context mContext;
    private final Delegate mDelegate;

    PermissionChecker(@NonNull Context context, @NonNull Delegate delegate) {
        mContext = context;
        mDelegate = delegate;
    }

    // Map of Permission to Delegate Scope.
    private static final HashMap<String, String> DELEGATE_SCOPES = new HashMap<>();

    static {
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS, DELEGATION_APP_RESTRICTIONS);
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL, DELEGATION_BLOCK_UNINSTALL);
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_CERTIFICATES, DELEGATION_CERT_INSTALL);
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE, DELEGATION_PACKAGE_ACCESS);
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, DELEGATION_PERMISSION_GRANT);
        DELEGATE_SCOPES.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, DELEGATION_SECURITY_LOGGING);
    }

    private static final HashMap<String, String> CROSS_USER_PERMISSIONS = new HashMap<>();

    static {
        // The permissions are all intrinsically global and therefore have no cross-user permission.
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FACTORY_RESET, null);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MTE, null);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SECURITY_LOGGING, null);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_STATUS_BAR, null);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_UPDATES, null);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, null);
        CROSS_USER_PERMISSIONS.put(SET_TIME, null);
        CROSS_USER_PERMISSIONS.put(SET_TIME_ZONE, null);

        // The permissions are all critical for securing data within the current user and
        // therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL for
        // cross-user calls.
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_KEYGUARD,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);
        if (Flags.lockNowCoexistence()) {
            CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,
                    MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);
        }
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL);

        // These permissions are required for securing device ownership without accessing user data
        // and therefore are protected with MANAGE_DEVICE_POLICY_ACROSS_USERS for cross-user calls.
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AIRPLANE_MODE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLUETOOTH,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CALLS, MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA, MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEFAULT_SMS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_INPUT_METHODS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MOBILE_NETWORK,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PACKAGE_STATE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CAPTURE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SMS, MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SAFE_BOOT,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_TIME, MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIFI, MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WIPE_DATA,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CONTENT_PROTECTION,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_FUNCTIONS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS);

        // These permissions may grant access to user data and therefore must be protected with
        // MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL for cross-user calls.
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APPS_CONTROL,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_AUTOFILL,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_BLOCK_UNINSTALL,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_CAMERA_TOGGLE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_DISPLAY,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_FUN,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCALE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCATION,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        if (!Flags.lockNowCoexistence()) {
            CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK,
                    MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        }
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_LOCK_TASK,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MODIFY_USERS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILES,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_PRINTING,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RESET_PASSWORD,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SCREEN_CONTENT,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_VPN,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WALLPAPER,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
        CROSS_USER_PERMISSIONS.put(MANAGE_DEVICE_POLICY_WINDOWS,
                MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL);
    }

    // Permissions of existing DPC types.
    private static final List<String> DEFAULT_DEVICE_OWNER_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT, MANAGE_DEVICE_POLICY_ACROSS_USERS,
            MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,
            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL, MANAGE_DEVICE_POLICY_AIRPLANE_MODE,
            MANAGE_DEVICE_POLICY_APPS_CONTROL, MANAGE_DEVICE_POLICY_APP_FUNCTIONS,
            MANAGE_DEVICE_POLICY_APP_RESTRICTIONS, MANAGE_DEVICE_POLICY_AUDIO_OUTPUT,
            MANAGE_DEVICE_POLICY_AUTOFILL, MANAGE_DEVICE_POLICY_BLUETOOTH,
            MANAGE_DEVICE_POLICY_CALLS, MANAGE_DEVICE_POLICY_CAMERA,
            MANAGE_DEVICE_POLICY_CERTIFICATES, MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,
            MANAGE_DEVICE_POLICY_CONTENT_PROTECTION, MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,
            MANAGE_DEVICE_POLICY_DEFAULT_SMS, MANAGE_DEVICE_POLICY_DISPLAY,
            MANAGE_DEVICE_POLICY_FACTORY_RESET, MANAGE_DEVICE_POLICY_FUN,
            MANAGE_DEVICE_POLICY_INPUT_METHODS, MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,
            MANAGE_DEVICE_POLICY_KEYGUARD, MANAGE_DEVICE_POLICY_LOCALE,
            MANAGE_DEVICE_POLICY_LOCATION, MANAGE_DEVICE_POLICY_LOCK,
            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS, MANAGE_DEVICE_POLICY_LOCK_TASK,
            MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS, MANAGE_DEVICE_POLICY_MICROPHONE,
            MANAGE_DEVICE_POLICY_MOBILE_NETWORK, MANAGE_DEVICE_POLICY_MODIFY_USERS,
            MANAGE_DEVICE_POLICY_MTE, MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,
            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY, MANAGE_DEVICE_POLICY_PACKAGE_STATE,
            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA, MANAGE_DEVICE_POLICY_PRINTING,
            MANAGE_DEVICE_POLICY_PROFILES, MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,
            MANAGE_DEVICE_POLICY_RESET_PASSWORD, MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,
            MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS, MANAGE_DEVICE_POLICY_SAFE_BOOT,
            MANAGE_DEVICE_POLICY_SCREEN_CAPTURE, MANAGE_DEVICE_POLICY_SCREEN_CONTENT,
            MANAGE_DEVICE_POLICY_SECURITY_LOGGING, MANAGE_DEVICE_POLICY_SMS,
            MANAGE_DEVICE_POLICY_STATUS_BAR, MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,
            MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS, MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,
            MANAGE_DEVICE_POLICY_TIME, MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING,
            MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER, MANAGE_DEVICE_POLICY_VPN,
            MANAGE_DEVICE_POLICY_WALLPAPER, MANAGE_DEVICE_POLICY_WIFI, MANAGE_DEVICE_POLICY_WINDOWS,
            MANAGE_DEVICE_POLICY_WIPE_DATA, SET_TIME, SET_TIME_ZONE,
            MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES);

    private static final List<String> FINANCED_DEVICE_OWNER_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_ACROSS_USERS, MANAGE_DEVICE_POLICY_ACROSS_USERS_FULL,
            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL, MANAGE_DEVICE_POLICY_APPS_CONTROL,
            MANAGE_DEVICE_POLICY_CALLS, MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES,
            MANAGE_DEVICE_POLICY_FACTORY_RESET, MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES,
            MANAGE_DEVICE_POLICY_KEYGUARD, MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS,
            MANAGE_DEVICE_POLICY_LOCK_TASK, MANAGE_DEVICE_POLICY_MODIFY_USERS,
            MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY, MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,
            MANAGE_DEVICE_POLICY_SAFE_BOOT, MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE,
            MANAGE_DEVICE_POLICY_TIME, MANAGE_DEVICE_POLICY_WIPE_DATA);

    /**
     * All the permissions granted to a profile owner.
     */
    private static final List<String> PROFILE_OWNER_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT,
            MANAGE_DEVICE_POLICY_ACROSS_USERS_SECURITY_CRITICAL, MANAGE_DEVICE_POLICY_APPS_CONTROL,
            MANAGE_DEVICE_POLICY_APP_FUNCTIONS, MANAGE_DEVICE_POLICY_APP_RESTRICTIONS,
            MANAGE_DEVICE_POLICY_AUDIO_OUTPUT, MANAGE_DEVICE_POLICY_AUTOFILL,
            MANAGE_DEVICE_POLICY_BLUETOOTH, MANAGE_DEVICE_POLICY_CALLS, MANAGE_DEVICE_POLICY_CAMERA,
            MANAGE_DEVICE_POLICY_CERTIFICATES, MANAGE_DEVICE_POLICY_CONTENT_PROTECTION,
            MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES, MANAGE_DEVICE_POLICY_DISPLAY,
            MANAGE_DEVICE_POLICY_FACTORY_RESET, MANAGE_DEVICE_POLICY_INPUT_METHODS,
            MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES, MANAGE_DEVICE_POLICY_KEYGUARD,
            MANAGE_DEVICE_POLICY_LOCALE, MANAGE_DEVICE_POLICY_LOCATION, MANAGE_DEVICE_POLICY_LOCK,
            MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS, MANAGE_DEVICE_POLICY_MANAGED_SUBSCRIPTIONS,
            MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION, MANAGE_DEVICE_POLICY_ORGANIZATION_IDENTITY,
            MANAGE_DEVICE_POLICY_PACKAGE_STATE, MANAGE_DEVICE_POLICY_PRINTING,
            MANAGE_DEVICE_POLICY_PROFILES, MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,
            MANAGE_DEVICE_POLICY_RESET_PASSWORD, MANAGE_DEVICE_POLICY_RUNTIME_PERMISSIONS,
            MANAGE_DEVICE_POLICY_SCREEN_CAPTURE, MANAGE_DEVICE_POLICY_SCREEN_CONTENT,
            MANAGE_DEVICE_POLICY_SUPPORT_MESSAGE, MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS,
            MANAGE_DEVICE_POLICY_TIME, MANAGE_DEVICE_POLICY_VPN, MANAGE_DEVICE_POLICY_WIPE_DATA,
            MANAGE_DEVICE_POLICY_QUERY_SYSTEM_UPDATES);

    /**
     * All the additional permissions granted to an organisation owned profile owner.
     */
    private static final List<String>
            ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_ACROSS_USERS, MANAGE_DEVICE_POLICY_AIRPLANE_MODE,
            MANAGE_DEVICE_POLICY_APPS_CONTROL, MANAGE_DEVICE_POLICY_COMMON_CRITERIA_MODE,
            MANAGE_DEVICE_POLICY_DEFAULT_SMS, MANAGE_DEVICE_POLICY_LOCALE,
            MANAGE_DEVICE_POLICY_MICROPHONE, MANAGE_DEVICE_POLICY_MOBILE_NETWORK,
            MANAGE_DEVICE_POLICY_MTE, MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION,
            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA, MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS,
            MANAGE_DEVICE_POLICY_SAFE_BOOT, MANAGE_DEVICE_POLICY_SECURITY_LOGGING,
            MANAGE_DEVICE_POLICY_SMS, MANAGE_DEVICE_POLICY_SYSTEM_UPDATES,
            MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,
            MANAGE_DEVICE_POLICY_WIFI, SET_TIME, SET_TIME_ZONE);

    /**
     * All the additional permissions granted to a Profile Owner on user 0.
     */
    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_AIRPLANE_MODE, MANAGE_DEVICE_POLICY_DISPLAY,
            MANAGE_DEVICE_POLICY_FUN, MANAGE_DEVICE_POLICY_LOCK_TASK,
            MANAGE_DEVICE_POLICY_MOBILE_NETWORK, MANAGE_DEVICE_POLICY_MODIFY_USERS,
            MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA, MANAGE_DEVICE_POLICY_PRINTING,
            MANAGE_DEVICE_POLICY_PROFILES, MANAGE_DEVICE_POLICY_PROFILE_INTERACTION,
            MANAGE_DEVICE_POLICY_SAFE_BOOT, MANAGE_DEVICE_POLICY_SMS,
            MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS, MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER,
            MANAGE_DEVICE_POLICY_WINDOWS, SET_TIME, SET_TIME_ZONE);

    /**
     * All the additional permissions granted to a Profile Owner on an unaffiliated user.
     */
    private static final List<String> ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS = List.of(
            MANAGE_DEVICE_POLICY_LOCK_TASK);

    /**
     * All the additional permissions granted to a Profile Owner on an affiliated user.
     */
    private static final List<String> ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =
            List.of(MANAGE_DEVICE_POLICY_STATUS_BAR);

    /**
     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and
     * {@link ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS}.
     */
    private static final List<String> PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS =
            new ArrayList();

    /**
     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and
     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS}.
     */
    private static final List<String> PROFILE_OWNER_ON_USER_0_PERMISSIONS = new ArrayList();

    /**
     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and
     * {@link ADDITIONAL_AFFILIATED_PROFIL_OWNER_ON_USER_PERMISSIONS}.
     */
    private static final List<String> AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS =
            new ArrayList();

    /**
     * Combination of {@link PROFILE_OWNER_PERMISSIONS} and
     * {@link ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS}.
     */
    private static final List<String> PROFILE_OWNER_ON_USER_PERMISSIONS = new ArrayList();

    private static final HashMap<Integer, List<String>> DPC_PERMISSIONS = new HashMap<>();

    static {
        // Organisation owned profile owners have all the permission of a profile owner plus
        // some extra permissions.
        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);
        PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS.addAll(
                ADDITIONAL_PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);
        // Profile owners on user 0 have all the permission of a profile owner plus
        // some extra permissions.
        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);
        PROFILE_OWNER_ON_USER_0_PERMISSIONS.addAll(ADDITIONAL_PROFILE_OWNER_ON_USER_0_PERMISSIONS);
        // Profile owners on users have all the permission of a profile owner plus
        // some extra permissions.
        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_PERMISSIONS);
        PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(ADDITIONAL_PROFILE_OWNER_ON_USER_PERMISSIONS);
        // Profile owners on affiliated users have all the permission of a profile owner on a user
        // plus some extra permissions.
        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(PROFILE_OWNER_ON_USER_PERMISSIONS);
        AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS.addAll(
                ADDITIONAL_AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);

        DPC_PERMISSIONS.put(DEFAULT_DEVICE_OWNER, DEFAULT_DEVICE_OWNER_PERMISSIONS);
        DPC_PERMISSIONS.put(FINANCED_DEVICE_OWNER, FINANCED_DEVICE_OWNER_PERMISSIONS);
        DPC_PERMISSIONS.put(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE,
                PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE_PERMISSIONS);
        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER_0, PROFILE_OWNER_ON_USER_0_PERMISSIONS);
        DPC_PERMISSIONS.put(PROFILE_OWNER, PROFILE_OWNER_PERMISSIONS);
        DPC_PERMISSIONS.put(PROFILE_OWNER_ON_USER, PROFILE_OWNER_ON_USER_PERMISSIONS);
        DPC_PERMISSIONS.put(AFFILIATED_PROFILE_OWNER_ON_USER,
                AFFILIATED_PROFILE_OWNER_ON_USER_PERMISSIONS);
    }

    // Map of user restriction to permission.
    private static final HashMap<String, String[]> USER_RESTRICTION_PERMISSIONS = new HashMap<>();

    static {
        USER_RESTRICTION_PERMISSIONS.put(UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
                new String[]{MANAGE_DEVICE_POLICY_PROFILES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ADD_CLONE_PROFILE,
                new String[]{MANAGE_DEVICE_POLICY_PROFILES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ADD_PRIVATE_PROFILE,
                new String[]{MANAGE_DEVICE_POLICY_PROFILES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ADD_USER,
                new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ADD_WIFI_CONFIG,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ADJUST_VOLUME,
                new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_AIRPLANE_MODE,
                new String[]{MANAGE_DEVICE_POLICY_AIRPLANE_MODE});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_AMBIENT_DISPLAY,
                new String[]{MANAGE_DEVICE_POLICY_DISPLAY});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_APPS_CONTROL,
                new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_AUTOFILL,
                new String[]{MANAGE_DEVICE_POLICY_AUTOFILL});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_BLUETOOTH,
                new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_BLUETOOTH_SHARING,
                new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CAMERA,
                new String[]{MANAGE_DEVICE_POLICY_CAMERA});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CAMERA_TOGGLE,
                new String[]{MANAGE_DEVICE_POLICY_CAMERA_TOGGLE});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CELLULAR_2G,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CHANGE_WIFI_STATE,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_BLUETOOTH,
                new String[]{MANAGE_DEVICE_POLICY_BLUETOOTH});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_BRIGHTNESS,
                new String[]{MANAGE_DEVICE_POLICY_DISPLAY});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_CREDENTIALS,
                new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_DATE_TIME,
                new String[]{MANAGE_DEVICE_POLICY_TIME});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_DEFAULT_APPS,
                new String[]{MANAGE_DEFAULT_APPLICATIONS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_LOCALE,
                new String[]{MANAGE_DEVICE_POLICY_LOCALE});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_LOCATION,
                new String[]{MANAGE_DEVICE_POLICY_LOCATION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_PRIVATE_DNS,
                new String[]{MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT,
                new String[]{MANAGE_DEVICE_POLICY_DISPLAY});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_TETHERING,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_VPN,
                new String[]{MANAGE_DEVICE_POLICY_VPN});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONFIG_WIFI,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONTENT_CAPTURE,
                new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CONTENT_SUGGESTIONS,
                new String[]{MANAGE_DEVICE_POLICY_SCREEN_CONTENT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CREATE_WINDOWS,
                new String[]{MANAGE_DEVICE_POLICY_WINDOWS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
                new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_DATA_ROAMING,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_DEBUGGING_FEATURES,
                new String[]{MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_FACTORY_RESET,
                new String[]{MANAGE_DEVICE_POLICY_FACTORY_RESET});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_FUN,
                new String[]{MANAGE_DEVICE_POLICY_FUN});
        if (Flags.associateDisallowGrantAdminWithPermission()) {
            USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_GRANT_ADMIN,
                    new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});
        }
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_INSTALL_APPS,
                new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
                new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_MICROPHONE_TOGGLE,
                new String[]{MANAGE_DEVICE_POLICY_MICROPHONE_TOGGLE});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_MODIFY_ACCOUNTS,
                new String[]{MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
                new String[]{MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_NETWORK_RESET,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_OUTGOING_BEAM,
                new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_OUTGOING_CALLS,
                new String[]{MANAGE_DEVICE_POLICY_CALLS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_PRINTING,
                new String[]{MANAGE_DEVICE_POLICY_PRINTING});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_REMOVE_USER,
                new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_RUN_IN_BACKGROUND,
                new String[]{MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SAFE_BOOT,
                new String[]{MANAGE_DEVICE_POLICY_SAFE_BOOT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SET_USER_ICON,
                new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SET_WALLPAPER,
                new String[]{MANAGE_DEVICE_POLICY_WALLPAPER});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE,
                new String[]{MANAGE_DEVICE_POLICY_PROFILE_INTERACTION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SHARE_LOCATION,
                new String[]{MANAGE_DEVICE_POLICY_LOCATION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SMS,
                new String[]{MANAGE_DEVICE_POLICY_SMS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
                new String[]{MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS});
        if (com.android.net.thread.platform.flags.Flags.threadUserRestrictionEnabled()) {
            USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_THREAD_NETWORK,
                    new String[]{MANAGE_DEVICE_POLICY_THREAD_NETWORK});
        }
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ASSIST_CONTENT,
                new String[]{MANAGE_DEVICE_POLICY_ASSIST_CONTENT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_ULTRA_WIDEBAND_RADIO,
                new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO,
                new String[]{MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_UNIFIED_PASSWORD,
                new String[]{MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_UNINSTALL_APPS,
                new String[]{MANAGE_DEVICE_POLICY_APPS_CONTROL});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_UNMUTE_DEVICE,
                new String[]{MANAGE_DEVICE_POLICY_AUDIO_OUTPUT});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_UNMUTE_MICROPHONE,
                new String[]{MANAGE_DEVICE_POLICY_MICROPHONE});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_USB_FILE_TRANSFER,
                new String[]{MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_USER_SWITCH,
                new String[]{MANAGE_DEVICE_POLICY_MODIFY_USERS});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_WIFI_DIRECT,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_WIFI_TETHERING,
                new String[]{MANAGE_DEVICE_POLICY_WIFI});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.ENSURE_VERIFY_APPS,
                new String[]{MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES});
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_SIM_GLOBALLY,
                new String[]{MANAGE_DEVICE_POLICY_MOBILE_NETWORK});

        // Restrictions not allowed to be set by admins.
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_RECORD_AUDIO, null);
        USER_RESTRICTION_PERMISSIONS.put(UserManager.DISALLOW_WALLPAPER, null);
    }

    /**
     * Delegate class that allows {@link PermissionChecker} to get information related to the
     * caller.
     */
    public interface Delegate {
        @DpcType
        int getDpcType(@NonNull CallerIdentity caller);

        @DpcType
        int getUserDpcType(@UserIdInt int user);

        boolean isCallerDevicePolicyManagementRoleHolder(@NonNull CallerIdentity caller);

        boolean isCallerDelegate(@NonNull CallerIdentity caller, @NonNull String scope);

        boolean hasAdminPolicy(int adminPolicy, @NonNull CallerIdentity caller);
    }

    /**
     * Returns whether the calling process has been granted the given permission.
     *
     * @param permission The name of the permission being checked.
     * @param caller     The identity of the calling application.
     */
    public boolean hasPermission(@NonNull String permission, @NonNull CallerIdentity caller) {
        if (permission == null) {
            return true;
        }

        // Check if the caller holds the permission
        if (mContext.checkPermission(permission, caller.getPid(), caller.getUid())
                == PERMISSION_GRANTED) {
            return true;
        }

        // Check if the permission is auto-granted to the DPC.
        if (mDelegate.getDpcType(caller) != NOT_A_DPC) {
            return PermissionChecker.DPC_PERMISSIONS.get(mDelegate.getDpcType(caller)).contains(
                    permission);
        }

        // Check the permission for the role-holder
        if (mDelegate.isCallerDevicePolicyManagementRoleHolder(caller)) {
            if (mDelegate.getUserDpcType(caller.getUserId()) != NOT_A_DPC) {
                return PermissionChecker.DPC_PERMISSIONS.get(
                        mDelegate.getUserDpcType(caller.getUserId())).contains(permission);
            }
            return false;
        }

        if (DELEGATE_SCOPES.containsKey(permission)) {
            return mDelegate.isCallerDelegate(caller, DELEGATE_SCOPES.get(permission));
        }

        return false;
    }

    /**
     * Returns whether the calling process has been granted permission to apply a device policy on
     * a specific user.
     *
     * @param permission   The name of the permission being checked.
     * @param caller       The identity of the calling application.
     * @param targetUserId The userId of the user which the caller needs permission to act on.
     */
    public boolean hasPermission(@NonNull String permission, @NonNull CallerIdentity caller,
            @UserIdInt int targetUserId) {
        boolean hasPermissionOnOwnUser = hasPermission(permission, caller);
        boolean hasPermissionOnTargetUser = true;
        if (hasPermissionOnOwnUser && caller.getUserId() != targetUserId) {
            hasPermissionOnTargetUser = hasPermission(CROSS_USER_PERMISSIONS.get(permission),
                    caller);
        }

        return hasPermissionOnOwnUser && hasPermissionOnTargetUser;
    }

    /**
     * Checks if the calling process has been granted permission to apply a device policy.
     *
     * @param permission The name of the permission being checked.
     * @param caller     The identity of the calling application.
     * @throws SecurityException if the caller has not been granted the given permission.
     */
    public void enforce(@NonNull String permission, @NonNull CallerIdentity caller)
            throws SecurityException {
        if (!hasPermission(permission, caller)) {
            throw new SecurityException("Caller does not have the required permissions for "
                    + "this user. Permission required: " + permission + ".");
        }
    }

    /**
     * Checks if the calling process has been granted permission to apply a device policy on a
     * specific user.
     * The given permission will be checked along with their associated cross-user permission if
     * it exists and the target user is different to the calling user.
     *
     * @param permission   The names of the permissions being checked.
     * @param caller       The identity of the calling application.
     * @param targetUserId The userId of the user which the caller needs permission to act on.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user.
     */
    public void enforce(@NonNull String permission, @NonNull CallerIdentity caller,
            @UserIdInt int targetUserId) throws SecurityException {
        enforce(permission, caller);
        if (targetUserId != caller.getUserId()) {
            enforce(CROSS_USER_PERMISSIONS.get(permission), caller);
        }
    }

    /**
     * Checks if the calling process has been granted permission to apply a device policy on the
     * calling user. Only one of the given permissions will be required to be held to pass this
     * check.
     *
     * @param permissions An array of the names of the permissions being checked.
     * @param caller      The identity of the calling application.
     * @throws SecurityException if the caller has not been granted the given permission.
     */
    public void enforce(@NonNull String[] permissions, @NonNull CallerIdentity caller)
            throws SecurityException {
        enforce(permissions, caller, caller.getUserId());
    }

    /**
     * Checks if the calling process has been granted permission to apply a device policy on a
     * specific user. Only one of the given permissions will be required to be held to pass this
     * check.
     * The given permissions will be checked along with their associated cross-user permissions if
     * they exist and the target user is different to the calling user.
     *
     * @param permissions  An array of the names of the permissions being checked.
     * @param caller       The identity of the calling application.
     * @param targetUserId The userId of the user which the caller needs permission to act on.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user.
     */
    public void enforce(@NonNull String[] permissions, @NonNull CallerIdentity caller,
            @UserIdInt int targetUserId) throws SecurityException {
        String heldPermission = "";
        for (String permission : permissions) {
            if (hasPermission(permission, caller)) {
                heldPermission = permission;
                break;
            }
        }
        if (heldPermission.isEmpty()) {
            throw new SecurityException("Caller does not have the required permissions for "
                    + "this user. One of the following permission required: " + Arrays.toString(
                    permissions));
        }
        enforce(heldPermission, caller, targetUserId);
    }

    /**
     * Checks if the calling process has been granted permission to apply a device policy on a
     * specific user.
     * The given permission will be checked along with its associated cross-user permission if it
     * exists and the target user is different to the calling user.
     *
     * @param deviceAdminPolicy The admin policy that should grant holders permission.
     * @param permissions       The names of the permissions being checked.
     * @param caller            The identity of the calling application.
     * @param targetUserId      The userId of the user which the caller needs permission to act on.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user.
     */
    public void enforce(@NonNull String[] permissions, int deviceAdminPolicy,
            @NonNull CallerIdentity caller, @UserIdInt int targetUserId) throws SecurityException {
        if (mDelegate.hasAdminPolicy(deviceAdminPolicy, caller)
                && caller.getUserId() == targetUserId) {
            return;
        }

        enforce(permissions, caller, targetUserId);
    }

    /**
     * Checks if the calling process has been granted permission to apply a user restriction on the
     * calling user.
     *
     * @param userRestriction The name of the user permission being checked. This must be a key
     *                        string defined in {@link UserManager}.
     * @param caller          The identity of the calling application.
     * @throws SecurityException if the caller has not been granted the given permission.
     */
    public void enforceForUserRestriction(@NonNull String userRestriction,
            @NonNull CallerIdentity caller) throws SecurityException {
        enforceForUserRestriction(userRestriction, caller, caller.getUserId());
    }

    /**
     * Checks if the calling process has been granted permission to apply a user restriction on a
     * specific user.
     *
     * The given permission will be checked along with their associated cross-user permissions if
     * they exist and the target user is different to the calling user.
     *
     * @param userRestriction The name of the user permission being checked. This must be a key
     *                        string defined in {@link UserManager}.
     * @param caller          The identity of the calling application.
     * @param targetUserId    The userId of the user which the caller needs permission to act on.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user.
     */
    public void enforceForUserRestriction(@NonNull String userRestriction,
            @NonNull CallerIdentity caller, @UserIdInt int targetUserId) throws SecurityException {
        String[] permissions = USER_RESTRICTION_PERMISSIONS.get(userRestriction);
        if (permissions.length == 0) {
            throw new SecurityException(
                    "Admins are not permitted to set User Restriction: " + userRestriction);
        }
        try {
            enforce(permissions, caller, targetUserId);
        } catch (SecurityException e) {
            throw new SecurityException(
                    "Caller does not hold the required permission for this " + "user restriction: "
                            + userRestriction + ".\n" + e.getMessage());
        }
    }

    /**
     * Checks whether the calling process has been granted permission to query a device policy on
     * ethe calling user.
     *
     * @param permission The name of the permission being checked.
     * @param caller     The identity of the calling application.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user
     *                           and if the user has not been granted {@link QUERY_ADMIN_POLICY}.
     */
    public void enforceCanQuery(String permission, @NonNull CallerIdentity caller)
            throws SecurityException {
        enforceCanQuery(permission, caller, caller.getUserId());
    }

    /**
     * Checks whether the calling process has been granted permission to query a device policy on
     * a specific user.
     * The given permission will be checked along with its associated cross-user permission if it
     * exists and the target user is different to the calling user.
     *
     * @param permission   The name of the permission being checked.
     * @param caller       The identity of the calling application.
     * @param targetUserId The userId of the user which the caller needs permission to act on.
     * @throws SecurityException if the caller has not been granted the given permission,
     *                           the associated cross-user permission if the caller's user is
     *                           different to the target user and if the user has not been granted
     *                           {@link QUERY_ADMIN_POLICY}.
     */
    public void enforceCanQuery(@NonNull String permission, @NonNull CallerIdentity caller,
            @UserIdInt int targetUserId) throws SecurityException {
        if (hasPermission(QUERY_ADMIN_POLICY, caller)) {
            return;
        }
        enforce(permission, caller, targetUserId);
    }

}
