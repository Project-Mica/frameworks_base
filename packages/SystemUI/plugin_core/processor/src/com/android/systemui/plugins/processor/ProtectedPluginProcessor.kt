/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.android.systemui.plugins.processor

import com.android.systemui.plugins.annotations.GeneratedImport
import com.android.systemui.plugins.annotations.ProtectedInterface
import com.android.systemui.plugins.annotations.ProtectedReturn
import com.android.systemui.plugins.annotations.SimpleProperty
import com.android.systemui.plugins.annotations.ThrowsOnFailure
import com.google.auto.service.AutoService
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.ProcessingEnvironment
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.Modifier
import javax.lang.model.element.PackageElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.TypeMirror
import javax.tools.Diagnostic.Kind
import kotlin.collections.ArrayDeque

/**
 * [ProtectedPluginProcessor] generates a proxy implementation for interfaces annotated with
 * [ProtectedInterface] which catches [Exception]s generated by the proxied target. Production
 * plugin interfaces should use this to catch [LinkagError]s as that protects the plugin host from
 * crashing due to out-of-date plugin code, where some call has changed so that the [ClassLoader] is
 * no longer able to resolve it correctly.
 *
 * [PluginInstance] observes these failures via [ProtectedMethodListener] and unloads the plugin in
 * question to prevent further issues. This persists through further load/unload requests.
 *
 * To centralize access to the proxy types, an additional type [PluginProtector] is also generated.
 * This class provides static methods which wrap an instance of the target interface in the proxy
 * type if it is not already an instance of the proxy.
 */
@AutoService(ProtectedPluginProcessor::class)
class ProtectedPluginProcessor : AbstractProcessor() {
    private lateinit var procEnv: ProcessingEnvironment

    override fun init(procEnv: ProcessingEnvironment) {
        this.procEnv = procEnv
    }

    override fun getSupportedAnnotationTypes(): Set<String> =
        setOf("com.android.systemui.plugins.annotations.ProtectedInterface")

    private data class TargetData(
        val attribute: TypeElement,
        val sourceType: Element,
        val sourcePkg: String,
        val sourceName: String,
        val outputName: String,
        val exTypeAttr: ProtectedInterface,
    )

    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
        val targets = mutableMapOf<String, TargetData>() // keyed by fully-qualified source name
        val genImports = mutableListOf<String>()
        for (attr in annotations) {
            for (target in roundEnv.getElementsAnnotatedWith(attr)) {
                // Find the target exception types to be used
                var exTypeAttr = target.getAnnotation(ProtectedInterface::class.java)
                if (exTypeAttr == null || exTypeAttr.exTypes.size == 0) {
                    exTypeAttr = ProtectedInterface.Default
                }

                val sourceName = "${target.simpleName}"
                val outputName = "${sourceName}Protector"
                val pkg = (target.getEnclosingElement() as PackageElement).qualifiedName.toString()
                targets.put(
                    "$target",
                    TargetData(attr, target, pkg, sourceName, outputName, exTypeAttr),
                )

                // This creates excessive imports, but it should be fine
                genImports.add("$pkg.$sourceName")
                genImports.add("$pkg.$outputName")
            }
        }

        if (targets.size <= 0) return false
        for ((_, sourceType, sourcePkg, sourceName, outputName, exTypeAttr) in targets.values) {
            // Find all methods in this type and all super types to that need to be implemented
            val types = ArrayDeque<TypeMirror>().apply { addLast(sourceType.asType()) }
            val impAttrs = mutableListOf<GeneratedImport>()
            val methods = mutableListOf<ExecutableElement>()
            while (types.size > 0) {
                val typeMirror = types.removeLast()
                if (typeMirror.toString() == "java.lang.Object") continue
                val type = procEnv.typeUtils.asElement(typeMirror)
                for (member in type.enclosedElements) {
                    if (member.kind != ElementKind.METHOD) continue
                    val method = member as ExecutableElement
                    methods.add(method)

                    if (method.isComposable()) {
                        impAttrs.add(GeneratedImport("androidx.compose.runtime.Composer"))
                        impAttrs.add(GeneratedImport("androidx.compose.runtime.HotReloaderKt"))
                    }
                }

                impAttrs.addAll(type.getAnnotationsByType(GeneratedImport::class.java))
                types.addAll(procEnv.typeUtils.directSupertypes(typeMirror))
            }

            val file = procEnv.filer.createSourceFile("$outputName")
            JavaFileWriter.writeTo(file.openWriter()) {
                pkg(sourcePkg)
                imports(
                    BASIC_IMPORTS,
                    genImports,
                    exTypeAttr.exTypes.toList(),
                    impAttrs.map { it.extraImport },
                )

                cls(outputName, interfaces = listOf(sourceName, "PluginWrapper<$sourceName>")) {
                    line("private static final String CLASS = \"$sourceName\";")
                    line("private static final String TAG = \"$outputName\";")

                    // Static factory method to prevent wrapping the same object twice
                    method(
                        "protect",
                        isStatic = true,
                        returnType = outputName,
                        args = {
                            arg("instance", "$sourceName")
                            arg("listener", "ProtectedPluginListener")
                        },
                    ) {
                        line("if (instance instanceof $outputName)")
                        line("    return ($outputName)instance;")
                        line("return new $outputName(instance, listener);")
                    }

                    // Member Fields
                    line("private $sourceName mInstance;")
                    line("private ProtectedPluginListener mListener;")
                    line("private boolean mHasError = false;")
                    line()

                    // Constructor
                    constructor(
                        visibility = "private",
                        args = {
                            arg("instance", sourceName)
                            arg("listener", "ProtectedPluginListener")
                        },
                    ) {
                        line("mInstance = instance;")
                        line("mListener = listener;")
                    }

                    // ToString override to help with debugging
                    line("@Override")
                    method("toString", returnType = "String") {
                        line("return String.format(\"$outputName[%s]@%h\", mInstance, hashCode());")
                    }

                    // Wrapped instance getter for version checker
                    method("getPlugin", returnType = sourceName) { line("return mInstance;") }

                    // Method implementations
                    for (method in methods) {
                        if (methods.any { method.simpleName.startsWith("${it.simpleName}\$") }) {
                            // Skip kotlin generated methods overrides
                            continue
                        }
                        writeProxyMethodImpl(sourceName, method, exTypeAttr, targets)
                    }
                }
            }
        }

        // Write a centralized static factory type to its own file. This is for convience so that
        // PluginInstance need not resolve each generated type at runtime as plugins are loaded.
        val factoryFile = procEnv.filer.createSourceFile("PluginProtector")
        JavaFileWriter.writeTo(factoryFile.openWriter()) {
            pkg("com.android.systemui.plugins")
            imports(FACTORY_IMPORTS, genImports)

            cls("PluginProtector", isFinal = true) {
                constructor(visibility = "private")

                line("private static final String TAG = \"PluginProtector\";")
                line()

                // Untyped factory SAM, private to this type.
                braceBlock("private interface Factory") {
                    line("Object create(Object plugin, ProtectedPluginListener listener);")
                }
                line()

                // Store a reference to each `protect` method in a map by interface type.
                parenBlock("private static final Map<Class, Factory> sFactories = Map.ofEntries") {
                    var isFirst = true
                    for (target in targets.values) {
                        if (!isFirst) completeLine(",")
                        target.apply {
                            startLine("entry($sourceName.class, ")
                            appendLine("(p, h) -> $outputName.protect(($sourceName)p, h))")
                        }
                        isFirst = false
                    }
                }
                completeLine(";")
                line()

                // Lookup the relevant factory based on the instance type, if not found return null.
                method(
                    "tryProtect",
                    isStatic = true,
                    returnType = "<T> T",
                    args = {
                        arg("target", "T")
                        arg("listener", "ProtectedPluginListener")
                    },
                ) {
                    // Accumulate interfaces from type and all base types
                    line("HashSet<Class> interfaces = new HashSet<Class>();")
                    line("Class current = target.getClass();")
                    braceBlock("while (current != null)") {
                        braceBlock("for (Class cls : current.getInterfaces())") {
                            line("interfaces.add(cls);")
                        }
                        line("current = current.getSuperclass();")
                    }
                    line()

                    // Check if any of the interfaces are marked protectable
                    line("int candidateCount = 0;")
                    line("Factory candidateFactory = null;")
                    braceBlock("for (Class cls : interfaces)") {
                        line("Factory factory = sFactories.get(cls);")
                        braceBlock("if (factory != null)") {
                            line("candidateFactory = factory;")
                            line("candidateCount++;")
                        }
                    }
                    line()

                    // No match, return null
                    braceBlock("if (candidateFactory == null)") {
                        line("Log.i(TAG, \"Wasn't able to wrap \" + target);")
                        line("return null;")
                    }

                    // Multiple matches, not supported
                    braceBlock("if (candidateCount >= 2)") {
                        var error = "Plugin implements more than one protected interface"
                        line("throw new UnsupportedOperationException(\"$error\");")
                    }

                    // Call the factory and wrap the target object
                    line("return (T)candidateFactory.create(target, listener);")
                }

                // Wraps the target with the appropriate generated proxy if it exists.
                method(
                    "protectIfAble",
                    returnType = "<T> T",
                    isStatic = true,
                    args = {
                        arg("target", "T")
                        arg("listener", "ProtectedPluginListener")
                    },
                ) {
                    line("T result = tryProtect(target, listener);")
                    line("return result != null ? result : target;")
                }
            }
        }

        return true
    }

    private fun JavaClassWriter.writeProxyMethodImpl(
        sourceName: String,
        method: ExecutableElement,
        exTypeAttr: ProtectedInterface,
        targets: Map<String, TargetData>,
    ) {
        line("@Override")
        method(
            "${method.simpleName}",
            isStatic = method.modifiers.contains(Modifier.STATIC),
            returnType = method.returnType.toString(),
            args = {
                // While copying the method signature for the proxy type, we
                // also accumulate arguments for the nested callsite.
                for (param in method.parameters) {
                    arg("${param.simpleName}", "${param.asType()}")
                }

                if (method.isComposable()) {
                    arg("composer", "Composer")
                    arg("i", "int")
                }
            },
        ) {
            line("final String METHOD = \"$methodName\";")

            fun callStatements() {
                val methodContainer = if (isStatic) sourceName else "mInstance"
                val nestedCall = "$methodContainer.$methodName($callArgs)"
                val returnGenericType = returnType.substringBefore("<")
                val returnGenericArgs =
                    returnType.substringAfter("<").substringBeforeLast(">").split(",")

                when {
                    isVoid -> line("$nestedCall;")
                    targets.containsKey(returnType) -> {
                        val targetType = targets.get(returnType)!!.outputName
                        line("return $targetType.protect($nestedCall, mListener);")
                    }
                    // Special case which wraps lists containing protected types
                    LIST_TYPES.contains(returnGenericType) &&
                        targets.containsKey(returnGenericArgs[0]) -> {
                        val listArg = returnGenericArgs[0].substringAfterLast(".")
                        val targetType = targets.get(returnGenericArgs[0])!!.outputName
                        line("$returnType source = $nestedCall;")
                        line("ArrayList<$listArg> dest = new ArrayList<$listArg>();")
                        braceBlock("for ($listArg item : source)") {
                            line("dest.add($targetType.protect(item, mListener));")
                        }
                        line("return dest;")
                    }
                    returnGenericArgs.any { targets.containsKey(it) } -> {
                        procEnv.messager.printMessage(
                            Kind.ERROR,
                            "$returnType has protected type as generic argument " +
                                "but is not currently supported by the processor.",
                        )
                        line("return $nestedCall;")
                    }
                    else -> line("return $nestedCall;")
                }
            }

            val simpleAttr = method.getAnnotation(SimpleProperty::class.java)
            fun errorStatements(isCaught: Boolean) {
                val retAttr = method.getAnnotation(ProtectedReturn::class.java)
                val throwAttr = method.getAnnotation(ThrowsOnFailure::class.java)

                when {
                    // Compose methods should rethrow since compose will throw a different error at
                    // a later point anyway due to the missing endgroup calls that are skipped.
                    method.isComposable() -> {
                        procEnv.messager.printMessage(
                            Kind.WARNING,
                            "$className.$methodName rethrows exceptions " +
                                "because it is annotated with @Composable",
                        )

                        if (isCaught) {
                            line("throw ex;")
                        } else {
                            line("return;")
                        }
                    }
                    // Method with throws declaration
                    throwAttr != null -> {
                        procEnv.messager.printMessage(
                            Kind.WARNING,
                            "$className.$methodName rethrows exceptions " +
                                "because it is annotated with @ThrowsOnFailure",
                        )

                        if (isCaught) {
                            line("throw ex;")
                        } else {
                            line(
                                "throw new IllegalStateException(" +
                                    "CLASS + \" has a previous failure.\")"
                            )
                        }
                    }
                    retAttr != null -> line(retAttr.statement)
                    isVoid -> line("return;")
                    // Declared as a simple property method
                    simpleAttr != null -> line("throw ex;")
                    else -> {
                        procEnv.messager.printMessage(
                            Kind.ERROR,
                            "$className.$methodName should be annotated with " +
                                "@ProtectedReturn, @SimpleProperty, or @ThrowsOnFailure",
                        )
                        line("// Error: No valid return value")
                    }
                }
            }

            // Return immediately if any previous call has failed, unless this has been marked with
            // @SimpleProperty. For simple property methods we attempt to execute anyway so that
            // later calls in a chained statements don't impede recovery.
            if (simpleAttr == null) {
                braceBlock("if (mHasError)") { errorStatements(isCaught = false) }
            }

            // Protect callsite in try/catch block
            braceBlock("try") { callStatements() }

            // Notify listener when a target exception is caught
            for (exType in exTypeAttr.exTypes) {
                val simpleName = exType.substringAfterLast(".")
                braceBlock("catch ($simpleName ex)") {
                    line("Log.wtf(CLASS, \"Failed to execute: \" + METHOD, ex);")
                    line("mHasError = mListener.onFail(CLASS, METHOD, ex);")
                    errorStatements(isCaught = true)
                }
            }
        }
    }

    companion object {
        val LIST_TYPES = setOf("java.util.List", "java.util.Collection")
        val BASIC_IMPORTS =
            listOf(
                "android.util.Log",
                "com.android.systemui.plugins.PluginWrapper",
                "com.android.systemui.plugins.ProtectedPluginListener",
            ) + LIST_TYPES

        val FACTORY_IMPORTS =
            listOf(
                "java.util.Map",
                "java.util.ArrayList",
                "java.util.HashSet",
                "android.util.Log",
                "static java.util.Map.entry",
            )

        /**
         * Checks whether a method is annotated with @Composable. We do this by matching the
         * annotation name against the mirror list because the compose runtime cannot be included
         * here directly.
         *
         * This allows us to special case Composable functions as the compose compiler adds special
         * arguments to those methods when they are compiled, but those changes aren't represented
         * in the stubs that this processor operates on.
         */
        fun ExecutableElement.isComposable(): Boolean {
            return this.hasAnnotation("androidx.compose.runtime.Composable")
        }

        fun Element.hasAnnotation(targetName: String): Boolean {
            for (attr in this.annotationMirrors) {
                if (attr.annotationType.toString() == targetName) {
                    return true
                }
            }
            return false
        }
    }
}
